@(
  doc: services.document.ExtendedDocumentMetadata,
  currentUser: Option[services.user.User],
  accessLevel: services.RuntimeAccessLevel,
  annotationCount: Long,
  annotationBounds: com.vividsolutions.jts.geom.Envelope,
  hasRelations: Boolean
 )(implicit request: RequestHeader, messages: Messages, webJarsUtil: org.webjars.play.WebJarsUtil)
<!DOCTYPE html>
<html>
  <head>
    <title>Downloads | @doc.author.map(_ + ": ")@doc.title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=0">
    @views.html.document.standardMeta(doc, annotationCount, Some(annotationBounds))
    <link rel="stylesheet" href="@routes.Assets.versioned("stylesheets/document/downloads/index.css")"/>
    @Html(webJarsUtil.script("1.12.0/jquery.min.js"))
    @if(doc.hasDataParts) {
      @Html(webJarsUtil.script("jquery-ui.min.js"))
      @Html(webJarsUtil.script("papaparse.min.js"))
      @Html(webJarsUtil.requireJs(routes.Assets.versioned("javascripts/document/downloads/app.js")))
      <script>
        window.config = {
          documentId: '@doc.id',
          dataPartSequenceNo: [ @doc.dataParts.map(_.getSequenceNo).mkString(",") ]
        }
      </script>
    }
  </head>
  <body>
    @views.html.document.iconbar(doc.document, currentUser, accessLevel, "downloads")

    <div class="sidebar">
      @views.html.sidebarHeader(doc.owner)
    </div>

    <div class="content">
      <div class="panel">
        <h2>@messages("common.annotations")</h2>
        <div class="inner">
          <ul>
            <li>
              <div class="description">
                <h3>CSV</h3>
                <p>@messages("document.downloads.annotations.csv.text")</p>
              </div>
              <div class="button-container">
                <a href="@controllers.document.downloads.routes.DownloadsController.downloadCSV(doc.id)" class="btn small"><span class="icon">&#xf019;</span> CSV</a>
              </div>
            </li>

            <li class="three-buttons">
              <div class="description">
                <h3>RDF</h3>
                <p>@messages("document.downloads.annotations.rdf.text")</p>
              </div>
              <div class="button-container">
                <a href="@controllers.document.downloads.routes.DownloadsController.downloadJSONLD(doc.id, None)" class="btn small"><span class="icon">&#xf019;</span> JSON-LD</a>
                <a href="@controllers.document.downloads.routes.DownloadsController.downloadTTL(doc.id)" class="btn small"><span class="icon">&#xf019;</span> RDF/Turtle</a>
                <a href="@controllers.document.downloads.routes.DownloadsController.downloadRDFXML(doc.id)" class="btn small"><span class="icon">&#xf019;</span> RDF/XML</a>
              </div>
            </li>

            @if(doc.isWMTSMap) {
              <li>
                <script>
                  function parseFragmentSelector(fragment) {
                    var regex = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g;

                    var matches = [...fragment.matchAll(regex)][0];
                    var [_, prefix, unit, a, b, c, d] = matches;

                    if (prefix !== 'xywh') throw new Error('Unsupported MediaFragment: ' + fragment);

                    if (unit && unit !== 'pixel') throw new Error(`Unsupported MediaFragment unit: ${unit}`);

                    var [x, y, w, h] = [a, b, c, d].map(parseFloat);

                    return {
                      type: 'Polygon',
                      coordinates: [[
                        [x,y], [x+w,y], [x+w,y+h], [x,y+h], [x,y]
                      ]]
                    }
                  }

                  function parseSvgSelector(value) {
                    var [a, b, str] = value.match(/(<polygon points=")([^"]*)/) || [];

                    if (!str) throw new Error('Unsupported SVG selector: ' + value);

                    var points = str.split(' ').map((p) => p.split(',').map(parseFloat));

                    return {
                      type: 'Polygon',
                      coordinates: [
                        [...points, points[0]]
                      ]
                    }
                  }

                  function downloadGeoJSON() {
                    var documentId = '@doc.id';

                    fetch(`/document/${documentId}/downloads/annotations/jsonld`)
                      .then(function(res) { return res.json(); })
                      .then(function(data) {
                        const features = data.map(annotation => {
                          var properties = {};

                          var transcription = annotation.body.find(b => b.purpose === 'transcribing');
                          if (transcription) {
                            properties.transcription = transcription.value;
                            properties.transcriber = transcription.creator;
                            properties.transcribed_at = transcription.modified;
                          }
                          
                          var tags = annotation.body.filter(b => b.purpose === 'tagging');
                          if (tags.length > 0)
                            properties.tags = tags.map(t => t.value).join(', ');

                          var { type, value } = annotation.target.selector[0];

                          let geometry; 

                          if (type === 'SvgSelector') {
                            geometry = parseSvgSelector(value);
                          } else if (type === 'FragmentSelector') {
                            geometry = parseFragmentSelector(value);
                          } else {
                            console.warn('Unsuported selector type: ' + type);
                          }

                          return { type: 'Feature', properties, geometry };
                        }).filter(f => f.geometry);

                        var collection = {
                          type: 'FeatureCollection',
                          features
                        };

                        var anchor = document.createElement('a');
                        anchor.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(collection));
                        anchor.download = `${documentId}.geojson`;
                        anchor.click();
                      });

                    return false;
                  }
                </script>
                <div class="description">
                  <h3>GeoJSON</h3>
                  <p>Download map annotations as GeoJSON.</p>
                </div>
                <div class="button-container">
                  <a href="#" onclick="return downloadGeoJSON()" class="btn small"><span class="icon">&#xf019;</span> GeoJSON</a>
                </div>
              </li>  
            }
          </ul>
        </div>
      </div>

      <div class="panel">
        <h2>Places</h2>
        <div class="inner">
          <ul>
            <li>
              <div class="description">
                <h3>GeoJSON</h3>
                <p>@messages("document.downloads.annotations.geojson.text")</p>
              </div>
              <div class="button-container">
                <a href="@controllers.document.downloads.routes.DownloadsController.downloadGeoJSON(doc.id)" class="btn small"><span class="icon">&#xf019;</span> GeoJSON</a>
              </div>
            </li>

            <li>
              <div class="description">
                <h3>KML <span class="beta">BETA</span></h3>
                <p>
                  Geo-located places as KML file, for viewing in Google Earth. You can also download a 
                  <a href="@controllers.document.downloads.routes.DownloadsController.downloadKML(doc.id, true)">slightly 
                  modified alternative KML serialization</a> which is suited specifically for the 
                  <a href="https://geobrowser.de.dariah.eu/" target="_blank">DARIAH GeoBrowser</a>.
                </p>
              </div>
              <div class="button-container">
                <a href="@controllers.document.downloads.routes.DownloadsController.downloadKML(doc.id, false)" class="btn small"><span class="icon">&#xf019;</span> KML</a>
              </div>
            </li>
          </ul>
        </div>
      </div>

      @if(hasRelations) {
        <div class="panel">
          <h2>Relations</h2>
          <div class="inner">
            <ul>
              <li>
                <div class="description">
                  <h3>Basic CSV</h3>
                  <p>
                    A basic CSV export of relationships in the document.
                  </p>
                </div>
                <div class="button-container">
                  <a href="@controllers.document.downloads.routes.DownloadsController.downloadRelationTriples(doc.id)" class="btn class"><span class="icon">&#xf019;</span> CSV</a>
                </div>
              </li>
              <li class="two-buttons">
                <div class="description">
                  <h3>Gephi CSV Node/Edge Lists</h3>
                  <p>
                    The relationships annotated in this document, as CSV files compatible with
                    the Node and Edge List format of the <a href="http://gephi.org/" target="_blank">Gephi</a>
                    graph visualization platform. Each annotation is represented as one node.
                  </p>
                </div>
                <div class="button-container">
                  <a href="@controllers.document.downloads.routes.DownloadsController.downloadGephiNodes(doc.id)" class="btn small"><span class="icon">&#xf019;</span> Nodes</a>
                  <a href="@controllers.document.downloads.routes.DownloadsController.downloadGephiEdges(doc.id)" class="btn small"><span class="icon">&#xf019;</span> Edges</a>
                </div>
              </li>
            </ul>
          </div>
        </div>
      }

      <div class="panel">
        <h2>Annotated Document</h2>
        <div class="inner">
          @if(accessLevel.canReadAll) {
            @if(doc.hasTextParts) {
              <ul>
                <li>
                  <div class="description">
                    <h3>TEI</h3>
                    <p>@messages("document.downloads.annotations.tei.text")</p>
                  </div>
                  <div class="button-container">
                    <a href="@controllers.document.downloads.routes.DownloadsController.downloadTEI(doc.id)" class="btn small"><span class="icon">&#xf019;</span> TEI/XML</a>
                  </div>
                </li>

                @if(doc.fileparts.size == 1 && doc.fileparts.head.getContentType == "TEXT_PLAIN") {
                  <li>
                    <div class="description">
                      <h3>Markdown &nbsp;<span class="beta">BETA</span></h3>
                      <p>A basic markdown serialization. Note: presently, only commentary is included in the export.</p>
                    </div>
                    <div class="button-container">
                      <a href="@controllers.document.downloads.routes.DownloadsController.downloadMarkdown(doc.id)" class="btn small"><span class="icon">&#xf019;</span> Markdown</a>
                    </div>
                  </li>
                }
              </ul>
            } else { @if(doc.hasDataParts) {
              <ul>
                @if(doc.dataParts.size == 1) {
                  <li>
                    <div class="description">
                      <h3>Merged CSV</h3>
                      <p>
                        Your original spreadsheet, with Recogito's additional data appended as extra columns.
                      </p>
                    </div>
                    <div class="button-container">
                      <a href="@controllers.document.downloads.routes.DownloadsController.downloadCSV(doc.id, true)" class="btn small"><span class="icon">&#xf019;</span> CSV</a>
                    </div>
                  </li>
                } else {
                  <li>
                    <div class="description">
                      <h3>Merged CSVs</h3>
                      <p>
                        Your original spreadsheets, with Recogito's additional data appended as extra columns, packaged in a Zip file.
                      </p>
                    </div>
                    <div class="button-container">
                      <a href="@controllers.document.downloads.routes.DownloadsController.downloadCSV(doc.id, true)" class="btn small"><span class="icon">&#xf019;</span> ZIP</a>
                    </div>
                  </li>
                }

                <li class="two-buttons gazetteer">
                  <div class="description">
                    <h3>Pelagios Gazetteer GeoJSON</h3>
                    <p>
                      Converts your original spreadsheet and annotations to GeoJSON, following
                      the Pelagios conventions on encoding gazetteers. <u>A field mapping
                      must be configured before running the conversion.</u>
                    </p>
                  </div>
                  <div class="button-container">
                    <a href="#" class="btn orange small settings"><span class="icon">&#xf06a;</span> Settings</a>
                    <form action="@controllers.document.downloads.routes.DownloadsController.downloadGeoJSON(doc.id, true)" method="POST">
                      <input type="hidden" id="json" name="json" />
                      <button type="submit" class="btn small download" disabled="true"><span class="icon">&#xf019;</span> GeoJSON</button>
                    </form>
                  </div>
                </li>
              </ul>
            } else {
              <p class="no-options">No download options available</p>
            }}
          } else {
            <p class="no-options">Some download options may be unavailable due to access restrictions.</p>
          }
        </div>
      </div>

      @if(doc.fileparts.size == 1 && doc.fileparts.head.getContentType == "TEXT_PLAIN") {
        <div class="panel">
          <h2>Other</h2>
          <div class="inner">
            <ul>
              <li>
                <div class="description">
                  <h3>IOB &nbsp;<span class="beta">BETA</span></h3>
                  <p>
                    The text tokenized in 
                    <a href="https://en.wikipedia.org/wiki/Inside%E2%80%93outside%E2%80%93beginning_(tagging)" target="_blank">IOB format</a>,
                    a common format used for machine learning training data.
                  </p>
                </div>
                <div class="button-container">
                  <a href="@controllers.document.downloads.routes.DownloadsController.downloadIOB(doc.id)" class="btn small"><span class="icon">&#xf019;</span> IOB</a>
                </div>
              </li>

              <li>
                <div class="description">
                  <h3>Spacy JSON &nbsp;<span class="beta">BETA</span></h3>
                  <p>
                    The text, line by line, in a JSON format usable as training data input for the   
                    <a href="https://spacy.io/usage/training" target="_blank">Spacy</a> machine learning library. <strong>Work in progress!</strong>
                  </p>
                </div>
                <div class="button-container">
                  <a href="@controllers.document.downloads.routes.DownloadsController.downloadSpacy(doc.id)" class="btn small"><span class="icon">&#xf019;</span> Spacy</a>
                </div>
              </li>
            </ul>
          </div>
        </div>
      }

      @if(doc.hasDataParts) {
        @helper.javascriptRouter("jsRoutes")(
          controllers.document.routes.javascript.DocumentController.getRaw
        )
      }
    </div>
  </body>
</html>
